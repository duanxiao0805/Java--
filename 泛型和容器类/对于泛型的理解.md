## 对于泛型的理解

我的初步理解是,就是不同的类型都可以用,不需要一次次的进行类型转换了

没有泛型的时候,参数就是一个个的变量,一个变量只能代表一种情况

泛型其实就是--->类型也可也像变量那样实现参数化

### 泛型类

泛型的实际参数必须是类类型? 怎么理解

**Java中是类类型?--->实际上存储的是对象的内存地址，而不是对象本身,就是可以除了基本类型之外的任意类型,包括类,接口等引用类型**

这个跟值和引用的区别联系起来了!

```java
public class test<T> {
    private T obj;

    public T getObj() {
        return obj;
    }

    public void setObj(T obj) {
        this.obj = obj;
    }

    public static void main(String[] args) {
        test<String> name = new test<>();
        name.setObj("duanxiao");
        test<Integer> age = new test<>();
        age.setObj(123);
    }
}
```

**分析一下具体程序的流程是怎么样的?**

这个String是创建对象的时候的实参,它会把类体所有T(泛型)替换掉,同理Integer也是这样

### 泛型方法

什么方法都可以定义成泛型方法(包括构造方法和普通方法)

除了定义之外,调用时和普通方法一样

**泛型方法与泛型类并没有联系,不需要保证是泛型类**

```java
public class test {
    public static void main(String[] args) {
        Integer[] nums = new Integer[] { 1, 2, 3 };
        test.f(nums);
        String[] strs = new String[] { "red" };
        test.f(strs);
    }

    public static <E> void f(E[] list) {
        for (int i = 0; i < list.length; i++)
            System.out.println(list[i]);
    }
}
```



**在泛型类中定义泛型方法,泛型类的类型参数所属的类和泛型方法的类型参数所属的类?**

```java
class test<T> {
    private T t;

    public T getObj() {
        return t;
    }

    public void setObj(T t) {
        this.t = t;
    }

    // 泛型方法
    public <U> void f(U u) {
        System.out.println(t.getClass().getName());
        System.out.println(u.getClass().getName());
    }

    public static void main(String[] args) {

    }
}

class test0 {
    public static void main(String[] args) {
        test<Integer> t = new test<>();
        t.setObj(5);
        t.f("duanxiao");
        t.f(8.0);
    }
}
```

就是验证一下,这个类中的泛型类型和泛型方法中的泛型类型属于谁?

分析一下程序:

这个类的泛型参数已经固定好了<Integer> 但是这个泛型方法泛型参数还没有确定

所以无论如何类的泛型参数一定是属于Integer的,而方法的泛型参数由传入的泛型参数确定

5--->Integer

"duanxiao"--->String

### 限制泛型的可用类型

**怎么理解呢?**

可以这样理解,如果没有限制的话,那么这个泛型的类型只要不是基本类型都可以

但是一旦限制了,就会根据后面限制类缩小范围,也就是说这个泛型必须是这个类,子类,或者是实现这个类接口的类

```java
class test<T extends Number> {
    T obj;

    public test() {

    }

    public test(T obj) {
        this.obj = obj;
    }

    public T getObj() {
        return obj;
    }

}

class Main {
    public static void main(String[] args) {
        test<Integer> n = new test<>();

        test<String> s = new test<>();
    }
}
```

就像这个泛型类的参数T,它必须满足是Number类或者是它的子类,或者是实现这个类的接口类

所以说下面实例的时候Integer可以,因为Integer是它的子类,但是String就不可以,因为String与Number类并没有直接联系



<T extends class> 如果class是一个接口,如果创建对象是,实例的泛型参数不是实现接口class的类,编译是不能通过的

```java
class L<T extends List> {
    T t;
}

class Main {
    public static void main(String[] args) {
        L<LinkedList> x = new L<LinkedList>();
        L<ArrayList> y = new L<ArrayList>();
    }
}
```

例如这个程序,因为泛型参数LinkedList和ArrayList都是实现List接口的类,所以都可以这样创建对象

```java
L<HashMap> z=new L<HashMap>();
```

但是这个HashMap并没有实现List接口,所以这段程序是错误的

### 泛型的类型通配符和泛型数组的应用

```java
class Solution {
    
}
pytho
```

